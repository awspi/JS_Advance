# 13_异常处理-js模块化

# 异常处理

**如何可以让一个函数告知外界自己内部出现了错误呢?** 通过throw关键字，抛出一个异常

**throw语句:**

- throw语句用于抛出一个用户自定义的异常;
- 当遇到throw语句时，**当前的函数执行**会被停止**(throw后面的语句不会执行**);
- 如果我们执行代码，就会报错，拿到错误信息的时候我们可以及时的去修正代码。

throw关键字可以抛出的类型

- 基本数据类型:比如number、string、Boolean
- 对象类型:对象类型可以包含更多的信息

```ts
function sum(num1, num2) {
  // 当传入的参数的类型不正确时, 应该告知调用者一个错误
  if (typeof num1 !== "number" || typeof num2 !== "number") {
    throw "parameters is error type~"
  }
  return num1 + num2
}
```

## Error类型

JavaScript提供了Error类，可以直接创建这个类的对象:

**Error包含三个属性:**

- **messsage**:创建Error对象时传入的message;
- **name**:Error的名称，通常和类的名称一致;
- **stack**:整个Error的错误信息，包括函数的调用栈，当我们直接打印Error对象时，打印的就是stack;

```ts
    const err = new Error("type不能为0")
    throw err
```

Error有一些自己的子类:

- **RangeError**:下标值越界时使用的错误类型;
- **SyntaxError**:解析语法错误时使用的错误类型; 
- **TypeError**:出现类型错误时，使用的错误类型;



## 异常的处理

一个函数抛出了异常，调用它的时候程序会被强制终止:

- 函数抛出了异常，但是我们并没有对这个异常进行处理，那么这个异常会继续传递到上一个函数调用中;
- 如果到了最顶层(全局)的代码中依然没有对这个异常的处理代码，这个时候就会报错并且终止程序的运行;

## 异常的捕获

使用try catch

在ES10(ES2019)中，catch后面绑定的error可以省略。

如果有一些必须要执行的代码，我们可以使用finally来执行:

- finally表示最终一定会被执行的代码结构
- 注意:如果try和finally中都有返回值，那么**会使用finally当中的返回值;**

```ts
function bar() {
  try {
  foo(0)
    console.log("bar函数后续的继续运行")
  } catch(err) {
    console.log("err:", err.message)
    // alert(err.message)
  } finally {
    console.log("finally代码执行~, close操作")
  }
}
```

# 模块化

- 模块化开发最终的目的是将程序划分成一个个小的结构;
- 这个结构中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构
- 这个结构可以将自己希望暴露的变量、函数、对象等导出给其结构使用;
- 也可以通过某种方式，导入另外结构中的变量、函数、对象等;

上面说提到的结构，就是模块;按照这种结构划分开发程序的过程，就是模块化开发的过程;

JavaScript本身，直到**ES6**(2015)才推出了自己的模块化方案;

- 在此之前，为了让JavaScript支持模块化，涌现出了很多不同的模块化规范:**AMD、CMD、CommonJS等;**

**CommonJS和ES6的模块化**

# CommonJS(cjs)

Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发

- 在Node中**每一个js文件都是一个单独的模块**
- 这个模块中包括CommonJS规范的核心变量:**exports、module.exports、require**

**模块化的核心是导出和导入，Node中对其进行了实现:**

- **`exports`**和**`module.exports`**可以负责对模块中的内容进行导出;
- **`require`**函数可以帮助我们导入其他模块(自定义模块、系统模块、第三方库模块)中的内容;

## module.exports

![image-20220718030149562](https://wsp-typora.oss-cn-hangzhou.aliyuncs.com/images/202207180301615.png)

CommonJS中是没有module.exports的概念的;

但是为了实现模块的导出，Node中使用的是Module的类，**每一个模块都是Module的一个实例，也就是 module;**

所以在Node中真正用于导出的其实根本不是exports，而是module.exports因为module才是导出的真正实现者;

![image-20220718031703826](https://wsp-typora.oss-cn-hangzhou.aliyuncs.com/images/202207180317851.png)



## exports导出

**exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出;**

![image-20220718032016791](https://wsp-typora.oss-cn-hangzhou.aliyuncs.com/images/202207180320820.png)

```ts
//源码
module.exports = {}
exports = module.exports
```

**module才是导出的真正实现者;**

```ts
//不能导出

//module.exports = {}
//exports 本身是指向 module.exports
exports = {
  name,
  age,
  sum
}
//最终导出的还是module.exports
//修改export的引用没意义
```

```ts
//不能导出
exports.name = name
exports.age = age
exports.sum = sum

module.exports = {}
//最终导出的还是module.exports
```

## require细节

require是一个函数，可以帮助我们引入一个文件(模块)中导出的对象。

### 查找规则

```
require(X)
```

**X是一个Node核心模块，比如path、http** 

- 直接返回核心模块，并且停止查找



**X是以 ./ 或 ../ 或 /(根目录)开头的**

第一步:将X<u>当做一个文件</u>在对应的目录下查找;

- 如果有后缀名，按照后缀名的格式查找对应的文件

- 如果没有后缀名，会按照如下顺序:

  - 直接查找文件X

  - 查找X.js文件

  - 查找X.json文件

  - 查找X.node文件

第二步:没有找到对应的文件，<u>将X作为一个目录</u>

- 查找目录下面的index文件
- 查找X/index.js文件
- 查找X/index.json文件
- 查找X/index.node文件


如果没有找到，那么报错:not found



**直接是一个X(没有路径)，并且X不是一个核心模块**

## 模块的加载过程

**结论一:模块在被第一次引入时，模块中的js代码会被运行一次**

**结论二:模块被多次引入时，会缓存，最终只加载(运行)一次**

- 这是因为每个模块对象module都有一个属性:loaded。
- 为false表示还没有加载，为true表示已经加载;

**结论三:如果有循环引入，那么加载顺序是什么?**

- Node采用的是**深度优先算法**:main -> aaa -> ccc -> ddd -> eee ->bbb

- <img src="https://wsp-typora.oss-cn-hangzhou.aliyuncs.com/images/202207272346572.png" alt="image-20220727234613482" style="zoom:50%;" />

## CommonJS规范缺点

**CommonJS加载模块是同步的:**

- 同步的意味着**只有等到对应的模块加载完毕，当前模块中的内容才能被运行;**
- 这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快;
- **浏览器加载js文件需要先从服务器将文件下载下来，**之后再加载运行;
- 那么采用同步的就意味着**后续的js代码都无法正常运行**，即使是一些简单的DOM操作;

**在浏览器中，我们通常不使用CommonJS规范:**

- 当然在webpack中使用CommonJS是另外一回事;
- 因为它会将我们的代码转成浏览器可以直接执行的代码;

**在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD:**

- 但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES
  Module代码的转换;
- AMD和CMD已经使用非常少了
